"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const node_fetch_1 = __importDefault(require("node-fetch"));
const path_1 = require("path");
const querystring_1 = __importDefault(require("querystring"));
const ignore_1 = __importDefault(require("ignore"));
const package_json_1 = __importDefault(require("../../package.json"));
const async_sema_1 = require("async-sema");
const fs_extra_1 = require("fs-extra");
const semaphore = new async_sema_1.Sema(10);
exports.API_FILES = 'https://api.zeit.co/v2/now/files';
exports.API_DEPLOYMENTS = 'https://api.zeit.co/v9/now/deployments';
exports.API_DEPLOYMENTS_LEGACY = 'https://api.zeit.co/v3/now/deployments';
exports.API_DELETE_DEPLOYMENTS_LEGACY = 'https://api.zeit.co/v2/now/deployments';
exports.EVENTS = new Set([
    // File events
    'hashes-calculated',
    'file_count',
    'file-uploaded',
    'all-files-uploaded',
    // Deployment events
    'created',
    'ready',
    'warning',
    'error',
    // Build events
    'build-state-changed',
]);
function parseNowJSON(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!filePath) {
            return {};
        }
        try {
            const jsonString = yield fs_extra_1.readFile(filePath, 'utf8');
            return JSON.parse(jsonString);
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error(e);
            return {};
        }
    });
}
exports.parseNowJSON = parseNowJSON;
const maybeRead = function (path, default_) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield fs_extra_1.readFile(path, 'utf8');
        }
        catch (err) {
            return default_;
        }
    });
};
function getNowIgnore(path) {
    return __awaiter(this, void 0, void 0, function* () {
        let ignores = [
            '.hg',
            '.git',
            '.gitmodules',
            '.svn',
            '.cache',
            '.next',
            '.now',
            '.npmignore',
            '.dockerignore',
            '.gitignore',
            '.*.swp',
            '.DS_Store',
            '.wafpicke-*',
            '.lock-wscript',
            '.env',
            '.env.build',
            '.venv',
            'npm-debug.log',
            'config.gypi',
            'node_modules',
            '__pycache__/',
            'venv/',
            'CVS',
        ];
        const nowIgnore = Array.isArray(path)
            ? yield maybeRead(path_1.join(path.find(fileName => fileName.includes('.nowignore'), '') || '', '.nowignore'), '')
            : yield maybeRead(path_1.join(path, '.nowignore'), '');
        const ig = ignore_1.default().add(`${ignores.join('\n')}\n${nowIgnore}`);
        return { ig, ignores };
    });
}
exports.getNowIgnore = getNowIgnore;
exports.fetch = (url, token, opts = {}, debugEnabled) => __awaiter(this, void 0, void 0, function* () {
    semaphore.acquire();
    const debug = createDebug(debugEnabled);
    let time;
    if (opts.teamId) {
        const parsedUrl = url_1.parse(url, true);
        const query = parsedUrl.query;
        query.teamId = opts.teamId;
        url = `${parsedUrl.href}?${querystring_1.default.encode(query)}`;
        delete opts.teamId;
    }
    opts.headers = opts.headers || {};
    // @ts-ignore
    opts.headers.Authorization = `Bearer ${token}`;
    // @ts-ignore
    opts.headers['user-agent'] = `now-client-v${package_json_1.default.version}`;
    debug(`${opts.method || 'GET'} ${url}`);
    time = Date.now();
    const res = yield node_fetch_1.default(url, opts);
    debug(`DONE in ${Date.now() - time}ms: ${opts.method || 'GET'} ${url}`);
    semaphore.release();
    return res;
});
const isWin = process.platform.includes('win');
exports.prepareFiles = (files, options) => {
    const preparedFiles = [...files.keys()].reduce((acc, sha) => {
        const next = [...acc];
        const file = files.get(sha);
        for (const name of file.names) {
            let fileName;
            if (options.isDirectory) {
                // Directory
                fileName = options.path
                    ? name.substring(options.path.length + 1)
                    : name;
            }
            else {
                // Array of files or single file
                const segments = name.split(path_1.sep);
                fileName = segments[segments.length - 1];
            }
            next.push({
                file: isWin ? fileName.replace(/\\/g, '/') : fileName,
                size: file.data.byteLength || file.data.length,
                sha,
            });
        }
        return next;
    }, []);
    return preparedFiles;
};
function createDebug(debug) {
    const isDebug = debug || process.env.NOW_CLIENT_DEBUG;
    if (isDebug) {
        return (...logs) => {
            process.stderr.write([`[now-client-debug] ${new Date().toISOString()}`, ...logs].join(' ') +
                '\n');
        };
    }
    return () => { };
}
exports.createDebug = createDebug;
