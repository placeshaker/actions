"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const recursive_readdir_1 = __importDefault(require("recursive-readdir"));
const path_1 = require("path");
const hashes_1 = __importStar(require("./utils/hashes"));
const upload_1 = __importDefault(require("./upload"));
const utils_1 = require("./utils");
const errors_1 = require("./errors");
var utils_2 = require("./utils");
exports.EVENTS = utils_2.EVENTS;
function buildCreateDeployment(version) {
    return function createDeployment(path, options = {}, nowConfig) {
        return __asyncGenerator(this, arguments, function* createDeployment_1() {
            var e_1, _a;
            const debug = utils_1.createDebug(options.debug);
            const cwd = process.cwd();
            debug('Creating deployment...');
            if (typeof path !== 'string' && !Array.isArray(path)) {
                debug(`Error: 'path' is expected to be a string or an array. Received ${typeof path}`);
                throw new errors_1.DeploymentError({
                    code: 'missing_path',
                    message: 'Path not provided',
                });
            }
            if (typeof options.token !== 'string') {
                debug(`Error: 'token' is expected to be a string. Received ${typeof options.token}`);
                throw new errors_1.DeploymentError({
                    code: 'token_not_provided',
                    message: 'Options object must include a `token`',
                });
            }
            const isDirectory = !Array.isArray(path) && fs_extra_1.lstatSync(path).isDirectory();
            let rootFiles;
            if (isDirectory && !Array.isArray(path)) {
                debug(`Provided 'path' is a directory. Reading subpaths... `);
                rootFiles = yield __await(fs_extra_1.readdir(path));
                debug(`Read ${rootFiles.length} subpaths`);
            }
            else if (Array.isArray(path)) {
                debug(`Provided 'path' is an array of file paths`);
                rootFiles = path;
            }
            else {
                debug(`Provided 'path' is a single file`);
                rootFiles = [path];
            }
            // Get .nowignore
            let { ig, ignores } = yield __await(utils_1.getNowIgnore(path));
            debug(`Found ${ig.ignores.length} rules in .nowignore`);
            let fileList;
            debug('Building file tree...');
            if (isDirectory && !Array.isArray(path)) {
                // Directory path
                const dirContents = yield __await(recursive_readdir_1.default(path, ignores));
                const relativeFileList = dirContents.map(filePath => path_1.relative(process.cwd(), filePath));
                fileList = ig
                    .filter(relativeFileList)
                    .map((relativePath) => path_1.join(process.cwd(), relativePath));
                debug(`Read ${fileList.length} files in the specified directory`);
            }
            else if (Array.isArray(path)) {
                // Array of file paths
                fileList = path;
                debug(`Assigned ${fileList.length} files provided explicitly`);
            }
            else {
                // Single file
                fileList = [path];
                debug(`Deploying the provided path as single file`);
            }
            if (!nowConfig) {
                // If the user did not provide a nowConfig,
                // then use the now.json file in the root.
                const fileName = 'now.json';
                const absolutePath = fileList.find(f => path_1.relative(cwd, f) === fileName);
                debug(absolutePath ? `Found ${fileName}` : `Missing ${fileName}`);
                nowConfig = yield __await(utils_1.parseNowJSON(absolutePath));
            }
            if (version === 1 &&
                nowConfig &&
                Array.isArray(nowConfig.files) &&
                nowConfig.files.length > 0) {
                // See the docs: https://zeit.co/docs/v1/features/configuration/#files-(array)
                debug('Filtering file list based on `files` key in now.json');
                const allowedFiles = new Set(['Dockerfile']);
                const allowedDirs = new Set();
                nowConfig.files.forEach(relPath => {
                    if (fs_extra_1.lstatSync(relPath).isDirectory()) {
                        allowedDirs.add(relPath);
                    }
                    else {
                        allowedFiles.add(relPath);
                    }
                });
                fileList = fileList.filter(absPath => {
                    const relPath = path_1.relative(cwd, absPath);
                    if (allowedFiles.has(relPath)) {
                        return true;
                    }
                    for (let dir of allowedDirs) {
                        if (relPath.startsWith(dir + '/')) {
                            return true;
                        }
                    }
                    return false;
                });
                debug(`Found ${fileList.length} files: ${JSON.stringify(fileList)}`);
            }
            // This is a useful warning because it prevents people
            // from getting confused about a deployment that renders 404.
            if (fileList.length === 0 ||
                fileList.every((item) => {
                    if (!item) {
                        return true;
                    }
                    const segments = item.split('/');
                    return segments[segments.length - 1].startsWith('.');
                })) {
                debug(`Deployment path has no files (or only dotfiles). Yielding a warning event`);
                yield yield __await({
                    type: 'warning',
                    payload: 'There are no files (or only files starting with a dot) inside your deployment.',
                });
            }
            const files = yield __await(hashes_1.default(fileList));
            debug(`Yielding a 'hashes-calculated' event with ${files.size} hashes`);
            yield yield __await({ type: 'hashes-calculated', payload: hashes_1.mapToObject(files) });
            const { token, teamId, force, defaultName, debug: debug_ } = options, metadata = __rest(options, ["token", "teamId", "force", "defaultName", "debug"]);
            debug(`Setting platform version to ${version}`);
            metadata.version = version;
            const deploymentOpts = {
                debug: debug_,
                totalFiles: files.size,
                nowConfig,
                token,
                isDirectory,
                path,
                teamId,
                force,
                defaultName,
                metadata,
            };
            debug(`Creating the deployment and starting upload...`);
            try {
                for (var _b = __asyncValues(upload_1.default(files, deploymentOpts)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const event = _c.value;
                    debug(`Yielding a '${event.type}' event`);
                    yield yield __await(event);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
}
exports.default = buildCreateDeployment;
