"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const https_1 = require("https");
const async_retry_1 = __importDefault(require("async-retry"));
const async_sema_1 = require("async-sema");
const utils_1 = require("./utils");
const _1 = require(".");
const deploy_1 = __importDefault(require("./deploy"));
const isClientNetworkError = (err) => {
    if (err.message) {
        // These are common network errors that may happen occasionally and we should retry if we encounter these
        return (err.message.includes('ETIMEDOUT') ||
            err.message.includes('ECONNREFUSED') ||
            err.message.includes('ENOTFOUND') ||
            err.message.includes('ECONNRESET') ||
            err.message.includes('EAI_FAIL') ||
            err.message.includes('socket hang up') ||
            err.message.includes('network socket disconnected'));
    }
    return false;
};
function upload(files, options) {
    return __asyncGenerator(this, arguments, function* upload_1() {
        var e_1, _a, e_2, _b;
        const { token, teamId, debug: isDebug } = options;
        const debug = utils_1.createDebug(isDebug);
        if (!files && !token && !teamId) {
            debug(`Neither 'files', 'token' nor 'teamId are present. Exiting`);
            return yield __await(void 0);
        }
        let missingFiles = [];
        debug('Determining necessary files for upload...');
        try {
            for (var _c = __asyncValues(deploy_1.default(files, options)), _d; _d = yield __await(_c.next()), !_d.done;) {
                const event = _d.value;
                if (event.type === 'error') {
                    if (event.payload.code === 'missing_files') {
                        missingFiles = event.payload.missing;
                        debug(`${missingFiles.length} files are required to upload`);
                    }
                    else {
                        return yield __await(yield yield __await(event));
                    }
                }
                else {
                    // If the deployment has succeeded here, don't continue
                    if (event.type === 'ready') {
                        debug('Deployment succeeded on file check');
                        return yield __await(yield yield __await(event));
                    }
                    yield yield __await(event);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) yield __await(_a.call(_c));
            }
            finally { if (e_1) throw e_1.error; }
        }
        const shas = missingFiles;
        yield yield __await({ type: 'file_count', payload: { total: files, missing: shas } });
        const uploadList = {};
        debug('Building an upload list...');
        const semaphore = new async_sema_1.Sema(700, { capacity: 700 });
        shas.map((sha) => {
            uploadList[sha] = async_retry_1.default((bail) => __awaiter(this, void 0, void 0, function* () {
                const file = files.get(sha);
                if (!file) {
                    debug(`File ${sha} is undefined. Bailing`);
                    return bail(new Error(`File ${sha} is undefined`));
                }
                yield semaphore.acquire();
                const fPath = file.names[0];
                const stream = fs_1.createReadStream(fPath);
                const { data } = file;
                let err;
                let result;
                try {
                    const res = yield utils_1.fetch(utils_1.API_FILES, token, {
                        agent: new https_1.Agent({ keepAlive: true }),
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/octet-stream',
                            'x-now-digest': sha,
                            'x-now-length': data.length,
                        },
                        body: stream,
                        teamId,
                    }, isDebug);
                    if (res.status === 200) {
                        debug(`File ${sha} (${file.names[0]}${file.names.length > 1 ? ` +${file.names.length}` : ''}) uploaded`);
                        result = {
                            type: 'file-uploaded',
                            payload: { sha, file },
                        };
                    }
                    else if (res.status > 200 && res.status < 500) {
                        // If something is wrong with our request, we don't retry
                        debug(`An internal error occurred in upload request. Not retrying...`);
                        const { error } = yield res.json();
                        err = new _1.DeploymentError(error);
                    }
                    else {
                        // If something is wrong with the server, we retry
                        debug(`A server error occurred in upload request. Retrying...`);
                        const { error } = yield res.json();
                        throw new _1.DeploymentError(error);
                    }
                }
                catch (e) {
                    debug(`An unexpected error occurred in upload promise:\n${e}`);
                    err = new Error(e);
                }
                finally {
                    stream.close();
                    stream.destroy();
                }
                semaphore.release();
                if (err) {
                    if (isClientNetworkError(err)) {
                        debug('Network error, retrying: ' + err.message);
                        // If it's a network error, we retry
                        throw err;
                    }
                    else {
                        debug('Other error, bailing: ' + err.message);
                        // Otherwise we bail
                        return bail(err);
                    }
                }
                return result;
            }), {
                retries: 3,
                factor: 2,
            });
        });
        debug('Starting upload');
        while (Object.keys(uploadList).length > 0) {
            try {
                const event = yield __await(Promise.race(Object.keys(uploadList).map((key) => uploadList[key])));
                delete uploadList[event.payload.sha];
                yield yield __await(event);
            }
            catch (e) {
                return yield __await(yield yield __await({ type: 'error', payload: e }));
            }
        }
        debug('All files uploaded');
        yield yield __await({ type: 'all-files-uploaded', payload: files });
        try {
            debug('Starting deployment creation');
            try {
                for (var _e = __asyncValues(deploy_1.default(files, options)), _f; _f = yield __await(_e.next()), !_f.done;) {
                    const event = _f.value;
                    if (event.type === 'ready') {
                        debug('Deployment is ready');
                        return yield __await(yield yield __await(event));
                    }
                    yield yield __await(event);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        catch (e) {
            debug('An unexpected error occurred when starting deployment creation');
            yield yield __await({ type: 'error', payload: e });
        }
    });
}
exports.default = upload;
