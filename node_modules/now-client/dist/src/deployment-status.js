"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sleep_promise_1 = __importDefault(require("sleep-promise"));
const ms_1 = __importDefault(require("ms"));
const utils_1 = require("./utils");
const ready_state_1 = require("./utils/ready-state");
/* eslint-disable */
function checkDeploymentStatus(deployment, token, version, teamId, debug) {
    return __asyncGenerator(this, arguments, function* checkDeploymentStatus_1() {
        let deploymentState = deployment;
        let allBuildsCompleted = false;
        const buildsState = {};
        let apiDeployments = version === 2 ? utils_1.API_DEPLOYMENTS : utils_1.API_DEPLOYMENTS_LEGACY;
        debug(`Using ${version ? `${version}.0` : '2.0'} API for status checks`);
        // If the deployment is ready, we don't want any of this to run
        if (ready_state_1.isDone(deploymentState)) {
            debug(`Deployment is already READY. Not running status checks`);
            return yield __await(void 0);
        }
        // Build polling
        debug('Waiting for builds and the deployment to complete...');
        while (true) {
            if (!allBuildsCompleted) {
                const buildsData = yield __await(utils_1.fetch(`${apiDeployments}/${deployment.id}/builds${teamId ? `?teamId=${teamId}` : ''}`, token));
                const data = yield __await(buildsData.json());
                const { builds = [] } = data;
                for (const build of builds) {
                    const prevState = buildsState[build.id];
                    if (!prevState || prevState.readyState !== build.readyState) {
                        debug(`Build state for '${build.entrypoint}' changed to ${build.readyState}`);
                        yield yield __await({ type: 'build-state-changed', payload: build });
                    }
                    if (build.readyState.includes('ERROR')) {
                        debug(`Build '${build.entrypoint}' has errorred`);
                        return yield __await(yield yield __await({ type: 'error', payload: build }));
                    }
                    buildsState[build.id] = build;
                }
                const readyBuilds = builds.filter((b) => ready_state_1.isDone(b));
                if (readyBuilds.length === builds.length) {
                    debug('All builds completed');
                    allBuildsCompleted = true;
                    yield yield __await({ type: 'all-builds-completed', payload: readyBuilds });
                }
            }
            else {
                // Deployment polling
                const deploymentData = yield __await(utils_1.fetch(`${apiDeployments}/${deployment.id || deployment.deploymentId}${teamId ? `?teamId=${teamId}` : ''}`, token));
                const deploymentUpdate = yield __await(deploymentData.json());
                if (deploymentUpdate.error) {
                    debug('Deployment status check has errorred');
                    return yield __await(yield yield __await({ type: 'error', payload: deploymentUpdate.error }));
                }
                if (ready_state_1.isReady(deploymentUpdate)) {
                    debug('Deployment state changed to READY');
                    return yield __await(yield yield __await({ type: 'ready', payload: deploymentUpdate }));
                }
                if (ready_state_1.isFailed(deploymentUpdate)) {
                    debug('Deployment has failed');
                    return yield __await(yield yield __await({
                        type: 'error',
                        payload: deploymentUpdate.error || deploymentUpdate,
                    }));
                }
            }
            yield __await(sleep_promise_1.default(ms_1.default('1.5s')));
        }
    });
}
exports.default = checkDeploymentStatus;
